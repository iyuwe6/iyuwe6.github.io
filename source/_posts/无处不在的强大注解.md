---
title: 无处不在的强大注解
date: 2018-09-14 17:23:27
tags: 
  - SpringBoot
categories: 
  - SpringBoot
---

Java注解是从JDK1.5开始引入的新特性，现在在大量的框架（如Spring）中都使用到了注解，使用注解能大大简化代码量，提高变成效率。总之，能否熟练的使用注解体现了一个Java程序员的水平高低。
<!--more-->
### 常见的注解示例 ##
**@Autowired**
@Autowired注解。可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。
原理：在启动Spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowired\@Resource或Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。
注意：在使用@Autowired时，首先在容器中查询对应类型的bean，如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；如果查询结果不止一个，那么@Autowired会根据名称来查找；如果查询结果为空，那么会抛出异常。解决办法是，使用required=false。

**@Service**
@Service("xxxService")注解是告诉Spring，当Spring要创建xxxServiceImpl的实例时，bean的名字必须叫做"xxxService"，这样当Action需要使用xxxServiceImpl的实例时，就可以由Spring创建好的"xxxService"，然后注入给Action。这个注解对应的是业务层Bean。

**@Resource**
@Resource注解与@Autowired注解作用非常相似。
@Resource的装配顺序：
1.@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配；
2.指定了name或者type则根据指定的类型去匹配bean;
3.指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错，然后，区分一下@Autowired和@Resource
两个注解的区别：
1.@Autowired默认按照byType方式进行bean匹配,@Resource默认按照byName方式进行bean匹配；
2.@Autowired就是Spring的注解，@Resource是J2EE的注解

**@Controller**
@Controller注解用于标记这个类时Controller，
然后使用@RequestMapping和@RequestParam等注解用以定义URL请求和Controller方法之间的映射，
这样的Controller就能被访问到。
此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet对象，
它们可以通过Controller的方法参数灵活的获取到。
@Controller对应表现层的Bean，也就是Action。例如：

    @Controller
    @Scope("prototype")
    public class UserAction extends BaseAction<User>{
    ......
    }
使用@Controller注解标识UserAction之后，就表示要把UserAction交给Spring容器管理，在Spring容器中会存在一个名字为"userAction"的action，这个名字是根据UserAction类名来取的。

**@RequestMapping**
程序员需要在控制器内部为每一个请求动作编写相应的处理方法。
@RequestMapping注解指示Spring用哪个类或方法处理请求动作，该注解可用于类或方法。
当该注解用于控制器类时，所有方法都将映射为相对于类级别的请求，
表示该控制器处理的所有请求都被映射到value属性所指示的路径下。

**@ResponseBody**
@ResponseBody注解表示该方法的返回结果直接写入HTTP响应正文ResponseBody中，一般在异步获取数据时使用，通常是用在@RequestMapping后，返回值通常解析为跳转路径，加上@ResponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP响应正文中。
作用是将controller的方法返回的对象通过适当的HttpMessageConverter转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML。
该注解可以将如下类型的数据做成json:
1. 基本数据类型，如boolean,String,int等
2. Map类型数据
3. 集合或数组
4. 实体对象
5. 实体对象集合

**@Configuration**
Spring使用@Configuration作为配置的注解。这个注解使用@Component作为元注解。当Spring发现某个类使用了@Configuration注解，就去将该类下使用@Bean注解的方法穿件Bean并放入到容器中。

**@Conditional**
理解SpringBoot的自动配置先要理解@Condtion注解。
@Bean:将当前对象放入到Spring的IOC容器中来管理。
@Conditional:满足特定条件时才会创建一个Bean放入到IOC容器中，SpringBoot就是利用这个特性进行自动配置。
@ConditionalOnXxx都是组合@Conditional元注解，使用了不同的条件Condition。
    @ConditionalOnBean：当容器里有指定Bean的条件下
    
    @ConditionalOnClass：当类路径下有指定类的条件下
    
    @ConditionalOnExpression：基于SpEL表达式作为判断条件
    
    @ConditionalOnJava：基于JV版本作为判断条件
    
    @ConditionalOnJndi：在JNDI存在的条件下差在指定的位置
    
    @ConditionalOnMissingBean：当容器里没有指定Bean的情况下
    
    @ConditionalOnMissingClass：当类路径下没有指定类的条件下
    
    @ConditionalOnNotWebApplication：当前项目不是Web项目的条件下
    
    @ConditionalOnProperty：指定的属性是否有指定的值
    
    @ConditionalOnResource：类路径是否有指定的资源
    
    @ConditionalOnSingleCandidate：当指定Bean在容器中只有一个，或者虽然有多个但是指定首选Bean
    
    @ConditionalOnWebApplication：当前项目是Web项目的条件下

**@SpringBootApplication**
这是一个复合注解，包括@ComponentScan、@SpringBootConfiguration和@EnableAutoConfiguration。
- @SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。
- @EnableAutoConfiguration的作用启动自动的配置，@EnableAutoConfiguration注解的意思就是Springboot根据你添加的jar包来配置你项目的默认配置，比如根据spring-boot-starter-web ，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。在下面博客会具体分析这个注解，快速入门的demo实际没有用到该注解。
- @ComponentScan，扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。是以前的&lt;context：component-scan&gt;（以前使用在xml中使用的标签，用来扫描包配置的平行支持）。

