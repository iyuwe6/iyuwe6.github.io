---
title: 学习JVM(1)——JVM内存模型
date: 2019-03-18 10:29:06
tags: 
  - JVM
categories: 
  - JVM
---

## 1.JVM简介
VM是物理机器的软件实现。Java是用在VM上运行的WORA(Write Once Run Anywhere)概念而开发的。编译器将Java文件编译为Java .class文件，然后将.class文件输入到JVM中，JVM会加载并执行类文件。

<!--more-->

下面是JVM的架构图。![](https://ws1.sinaimg.cn/large/006aBttAly1g1h2a4s8s7j30il0gc74g.jpg)

由上面的架构图可知，JVM分为三个主要的子系统：
1. 类加载器
2. 运行时数据区
3. 执行引擎

### 1. 类加载器
Java的动态类加载功能由类加载器处理。它在运行时，而不是编译时首次引用类的时候加载、链接、并初始化类的文件。
#### 1.1 加载
类通过此组件加载。主要有以下三个类加载器：
1. BootStrap Class Loader——负责加载来自于BootStrap类路径的类，就是rt.jar。此加载程序将给予最高优先级。
2. Extension Class Loader——负责加载在ext文件夹(jre\lib)内的类。
3. Application Class Loader——负责加载应用程序级类路径，路径提到环境变量等。
上面的类加载器在加载类文件时遵循委托层次(Delegation Hierarchy)算法。
#### 1.2 链接
1. 验证——字节码验证器将验证生成的字节码是否正确，如果验证失败，我们将得到verification error
2. 准备——对于所有的静态变量，内存将被分配和配置默认值
3. 解决——所有的符号存储器引用都将替换为来自Method Area的原始引用
#### 1.3 初始化
这是类加载的最后阶段，这里所有的静态变量都将被赋予原始值，并执行静态块。
### 2. 运行时数据区
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，总共包括以下几个运行时数据区域。

![](https://ws1.sinaimg.cn/large/006aBttAly1g1h28sthjgj30u00nbdh7.jpg)

由上图可知，运行时数据区主要分为几个主要组件：
- **程序计数器(Program Counter Register)**——一块较小的内存空间，当前线程所执行的字节码的信号指示器。字节码解释器就是通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需依赖计数器来完成。注意：如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。线程私有，生命周期与线程同生共死。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。

- **虚拟机栈(VM Stack)**——线程私有，生命周期与线程相同。
  先来说下Java指令的构成：
  Java指令由**操作码**（方法本身）和**操作数**（方法内部变量）组成。
  1）方法本身是指令的操作码部分，保存在Stack中；
  2）方法内部变量（局部变量）作为指令的操作数部分，跟在指令的操作码之后，保存在Stack中（实际上是基本数据类型保存在Stack中，对象类型在Stack中保存地址，在Heap中保存内容）；
  虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。其中64位的long和double会占用2个局部变量空间(slot，一个32位)，其他占1个。局部变量表所需的空间在编译期间完成分配，当进入一个方法时，其需要在帧中分配多大的局部变量空间时确定的，运行期间不会改变大小。局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建，在创建的时候只需分配事先在编译期规定好的大小即可，运行过程中，大小不会改变。
  Java虚拟机规范中对该区域规定了两种异常情况：
  (1)如线程请求的深度大于虚拟机所允许的深度，栈溢出，例如递归时，抛出StackOverflowError异常；
  (2)虚拟机栈动态扩展无法申请到足够的内存时，抛出OutOfMemoryError异常；
  注意：当方法传递参数时实际上是一个方法将自己栈帧中局部变量表的**副本**传递给另一个方法栈帧中的局部变量表，不管数据类型是什么。

  虚拟机栈由以下几个部分组成：

  1. 基本元素——栈帧

     栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。

  2. 局部变量表

     局部变量表是一组变量值的存储空间，一个以字长为单位，从0开始计数的数组，用于存放方法参数和局部变量。变量槽(Variable Slot)是局部变量表的最小单位，没有强制规定大小为32位，虽然32位足够存放大部分类型的数据。一个Slot可以存放boolean、byte、char、short、reference和returnAddress 8种类型。其中reference表示对一个对象实例的引用。returnAddress则指向了一条字节码指令的地址。对于64位的long和double变量而言，虚拟机会为其分配两个连续的Slot空间。虚拟机通过索引定位的方式使用局部变量表。之前我们知道，局部变量表存放的是方法参数和局部变量。当调用的方法是非static方法时，局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，即"this"关键字指向的对象。分配完方法参数后，便会依次分配方法内部定义的局部变量。

     为了节省栈帧空间，局部变量表中的Slot是可以重用的。当离开了某些变量的作用域之后，这些变量对应的Slot就可以交给其他变量使用。

  3. 操作数栈

     操作数栈被组织成一个以字长为单位的数组。但不是通过索引来访问，而是通过标准栈操作（压栈和出栈）来访问。方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。

     在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠，令下面的部分操作数栈与上面的局部变量表重叠在一起，这样在方法调用时就可以共用一部分数据，无需进行额外的参数复制传递。

  4. 帧数据区

     栈帧需要一些数据来支持常量池解析、正常方法返回和异常处理等。在帧数据区中保存着访问常量池的指针，方便程序访问常量池。此外，当函数返回或者出现异常时，虚拟机必须恢复调用者函数的栈帧，并让调用者函数继续执行下去。对于异常处理，虚拟机必须有一个异常处理表，方便在发生异常的时候找到处理异常的代码，因此异常处理表也是帧数据区中重要的一部分。

  5. 动态链接

     每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另一部分在每一次运行期间转化为直接引用，这部分称为动态链接。

  6. 方法返回地址

     当一个方法开始执行时，只有两种方式可以退出这个方法，第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。

     另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。

- **本地方法栈(Native Method Stack)**——Java虚拟机可能会使用到传统的栈来支持native方法（使用Java语言以外的其他语言编写的方法）的执行。线程私有，如Sun HotSpot虚拟机直接把本地方法和虚拟机栈合二为一。
  Java虚拟机规范中对该区域规定了两种异常情况：
  (1)如线程请求的深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
  (2)虚拟机栈动态扩展无法申请到足够的内存时，抛出OutOfMemoryError异常。

- **Java堆(Java Heap)**——Java堆是JVM管理的内存中最大的一块，是所有线程共享的内存区域，随虚拟机的启动而创建。该区域唯一目的是存放对象实例，几乎所有对象实例都在堆里面分配。在堆中分配一定的内存来保存对象实例，实际上也只是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的方法（以栈帧的形式保存在Stack中）。Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，如同磁盘空间一样，既可以实现固定大小，也可以扩展，当前主流虚拟机都是按照扩展来实现的（通过-Xms和-Xmx控制）。
  java堆是垃圾收集器管理的主要区域，因此也叫“GC堆”，细分为新生代和老生代，新生代又可以分为Eden空间、From Survivor空间、To Survivor空间，默认情况下新生代按照8:1:1的比例来分配。
  Java虚拟机规范中对该区域规定了OutOfMemoryError异常：如果堆中没有内存完成实例分配，并且堆无法再扩展则抛出OutOfMemoryError异常。（当Old区被放满的之后，进行Full GC，之后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，则出现OOM错误，或者直接存放大对象大数组，导致老年代空间不足）

- **方法区(Method Area)**——方法区与Java堆都是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在HotSpot中用永久代来实现方法区，而其他虚拟机（如BEA JRockit、IBM J9等）是不存在永久代的。
  **Java7中已经将运行时常量池从永久代移除，在Java堆中开辟了一块区域存放运行时常量池。而在Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。**
  元空间的本质和永久代类似。都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：-XX:MetaspaceSize，初始空间大小，-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
  Java虚拟机规范中对方法区规定了OutOfMemoryError异常：如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。

- **运行时常量池(Runtime Constant Pool)**——运行时常量池是方法区的一部分。线程共享。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的常量池中。static修饰的静态变量也存放在方法区中，但不是在常量池中（不能修饰局部变量），不能在一个方法内部定义static变量（final可以），只能定义为成员变量。当这个类被Java虚拟机加载后，class文件中的常量就放在方法区的运行时常量池中。而且在运行期间，可以向常量池添加新的常量，如String类的intern()方法就能在运行期间向常量池中添加字符串常量。当运行时常量池中的某项变量没有被对象引用时，同时也没有被变量引用时，那么就需要垃圾收集器回收。运行时常量池就是这个类型用到的常量的一个有序集合。包括直接常量（基本类型，String)和对其他类型、方法、字段的符号引用。例如：
  - 类和接口的全限定名；
  - 字段的名称和描述符；
  - 方法的名称和描述符。
  池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所有常量池在Java的动态链接中起了核心作用。
  Java虚拟机规范中对该区域规定了OutOfMemoryError异常：当常量池无法申请到内存时抛出了OutOfMemoryError异常。

- **直接内存**——直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM异常。

### 3. 执行引擎
分配给运行时数据区的字节码由执行引擎执行，执行引擎读取字节码并逐个执行它。
1. 解释器——解释器解释字节码较快，但执行慢。解释器的缺点是当一个方法被多次调用时，每次都需要新的解释。
2. JIT编译器——JIT编译器消除了解释器的缺点。执行引擎将在转换字节码时使用解释器的帮助，但是当它发现重复的代码时，它使用JIT编译器，编译器会编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，从而提高系统性能。JIT的构成组件包括：
  - 中间代码生成器——生成中间代码
  - 代码优化器——负责优化上面生成的中间代码
  - 目标代码生成器——负责生成机器代码或本地代码
  - 分析器——一个特殊组件，负总责查找热点，即该方法是否被多次调用
3. 垃圾收集器——收集和删除未引用的对象。可以通过调用“System.gc()”触发垃圾收集器，但不能保证执行。JVM的垃圾回收收集创建的对象。
  - Java本机接口(JNI)——JNI将与本地方法库进行交互，并提供执行引擎所需的本地库。
  - 本地方法库——它是执行引擎所需的本地库的集合。

**补充**：
通过一张图来了解如何通过参数来控制各区域的的内存大小

![](https://ws1.sinaimg.cn/large/006aBttAly1g1h2c7wb67j30p009v40d.jpg)
控制参数

- -Xms设置堆的最小空间大小。

- -Xmx设置堆的最大空间大小。

- -XX:NewSize设置新生代最小空间大小。

- -XX:MaxNewSize设置新生代最大空间大小。

- -XX:PermSize设置永久代最小空间大小。

- -XX:MaxPermSize设置永久代最大空间大小。

- -Xss:设置每个线程的堆栈大小。
  没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。

  > 老年代空间大小=堆空间大小-新生代空间大小

**OutOfMemoryError出现的几种情况：**
对内存结构的清晰认识同样可以帮助理解不同的OutOfMemoryErrors:
1. Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space
原因：对象不能被分配到堆内存中
2. Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space
原因：类或者方法不能被加载到持久代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库
3. Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit
原因：创建的数组大于堆内存的空间
4. Exception in thread “main”: java.lang.OutOfMemoryError: request <size> bytes for <reason>. Out of swap space?
原因：本地分配失败。JNI、本地库或者Java虚拟机都是从本地堆中分配内存空间。
5. Exception in thread “main”: java.lang.OutOfMemoryError: <reason> <stack trace>（Native method）
原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现。

**总结：**

1. 按照是否线程共享，JVM内存区域可分为：线程共享（Java堆、方法区）和非线程共享（虚拟机栈、本地方法区、程序计数器）；
2. Java程序的工作过程：一个Java源程序文件，会被编译为字节码文件（以class为扩展名），每个java程序都需要运行在自己的JVM上，然后告知JVM程序的运行入口，再被JVM通过字节码解释器加载运行；
3. JVM初始运行的时候都会分配好方法区(Method Area)和堆(Heap)，而JVM每遇到一个线程，就为其分配一个程序计数器(Program Counter Register)，虚拟机栈(VM Stack)和本地方法栈(Native Method)，当线程结束时，三者（程序计数器、虚拟机栈和本地方法栈）所占用的内存空间也会被释放掉。非线程共享的三个区域的生命周期与所属线程相同，而线程共享的两个区域与JAVA程序运行的生命周期相同，所以这也是垃圾回收只发生在线程共享的区域（实际上对大部分虚拟机来说只发生在Heap上）的原因。

[1]: https://www.cnblogs.com/wangjzh/p/5258254.html
[2]:https://juejin.im/post/5b235883e51d4558b64f051a
[3]:https://hugua.iteye.com/blog/2350700
[4]:http://www.ityouknow.com/jvm/2017/08/25/jvm-memory-structure.html
[5]:https://blog.csdn.net/u010055527/article/details/79694058


